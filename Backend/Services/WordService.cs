using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using BackendFramework.Interfaces;
using BackendFramework.Models;
using BackendFramework.Otel;

namespace BackendFramework.Services
{
    /// <summary> More complex functions and application logic for <see cref="Word"/>s </summary>
    public class WordService(ISemanticDomainCountRepository semDomCountRepo, IWordRepository wordRepo,
        ISemanticDomainCountService semDomCountService) : IWordService
    {
        private readonly ISemanticDomainCountRepository _semDomCountRepo = semDomCountRepo;
        private readonly IWordRepository _wordRepo = wordRepo;
        private readonly ISemanticDomainCountService _semDomCountService = semDomCountService;

        private const string otelTagName = "otel.WordService";

        /// <summary>
        /// Clear the given word's Id and Metadata to be generated by the word repo,
        /// and add the given userId to EditedBy if it's nonempty and not already last on the list.
        /// </summary>
        private static Word PrepEditedData(string userId, Word word)
        {
            word.Id = "";
            word.Modified = "";
            if (!string.IsNullOrWhiteSpace(userId) && userId != word.EditedBy.LastOrDefault(""))
            {
                word.EditedBy.Add(userId);
            }
            return word;
        }

        /// <summary> Creates a new word with updated edited data. </summary>
        /// <returns> The created word </returns>
        public async Task<Word> Create(string userId, Word word)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "creating a word");

            var createdWord = await _wordRepo.Create(PrepEditedData(userId, word));
            await _semDomCountService.UpdateCountsForWord(createdWord);
            return createdWord;
        }

        /// <summary> Creates new words with updated edited data. </summary>
        /// <returns> The created word </returns>
        public async Task<List<Word>> Create(string userId, List<Word> words)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "creating words");

            var createdWords = await _wordRepo.Create(words.Select(w => PrepEditedData(userId, w)).ToList());
            await _semDomCountService.UpdateCountsForWords(createdWords);
            return createdWords;
        }

        /// <summary> Adds a new word with updated edited data. </summary>
        /// <returns> The added word </returns>
        private async Task<Word> Add(string userId, Word word)
        {
            return await _wordRepo.Add(PrepEditedData(userId, word));
        }

        /// <summary> Removes audio with specified fileName from a word </summary>
        /// <returns> New word </returns>
        public async Task<Word?> DeleteAudio(string projectId, string userId, string wordId, string fileName)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "deleting an audio");

            // We only want to update words that are in the frontier
            var wordWithAudioToDelete = await _wordRepo.DeleteFrontier(projectId, wordId, fileName);
            if (wordWithAudioToDelete is null)
            {
                return null;
            }

            wordWithAudioToDelete.Audio.RemoveAll(a => a.FileName == fileName);
            wordWithAudioToDelete.History.Add(wordId);

            return await Create(userId, wordWithAudioToDelete);
        }

        /// <summary> Deletes a word from the frontier </summary>
        /// <returns> The deleted word, or null if not found </returns>
        public async Task<Word?> DeleteFrontierWord(string projectId, string wordId)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "deleting a word from Frontier");

            var word = await _wordRepo.DeleteFrontier(projectId, wordId);
            if (word is null)
            {
                return null;
            }

            // Decrement counts for the deleted word's semantic domains
            await _semDomCountService.UpdateCountsForWordDeletion(word);
            return word;
        }

        /// <summary> Deletes words from the frontier </summary>
        /// <returns> The number of words deleted </returns>
        public async Task<int> DeleteFrontierWords(string projectId, List<string> wordIds)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "deleting words from Frontier");

            var deletedCount = 0;
            foreach (var wordId in wordIds)
            {
                if (await _wordRepo.DeleteFrontier(projectId, wordId) is not null)
                {
                    deletedCount++;
                }
            }
            return deletedCount;
        }

        /// <summary> Deletes frontier word and updates it as deleted in word collection </summary>
        /// <returns> The id of new word, or null if not found </returns>
        public async Task<string?> MakeFrontierDeleted(string projectId, string userId, string wordId)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "deleting a word from Frontier");

            var word = await DeleteFrontierWord(projectId, wordId);
            if (word is null)
            {
                return null;
            }

            word.ProjectId = projectId;
            word.Accessibility = Status.Deleted;
            word.History.Add(wordId);

            return (await Add(userId, word)).Id;
        }

        /// <summary> Restores words to the Frontier </summary>
        /// <returns> A bool: true if successful, false if any don't exist or are already in the Frontier. </returns>
        public async Task<bool> RestoreFrontierWords(string projectId, List<string> wordIds)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "restoring words to Frontier");

            var words = new List<Word>();
            foreach (var id in wordIds)
            {
                var word = await _wordRepo.GetWord(projectId, id);
                if (word is null || await _wordRepo.IsInFrontier(projectId, id))
                {
                    return false;
                }
                words.Add(word);
            }
            await _wordRepo.AddFrontier(words);
            await _semDomCountService.UpdateCountsForWords(words);
            return true;
        }

        /// <summary> Makes a new word in the Frontier with changes made </summary>
        /// <returns> Id of updated word, or null if not found </returns>
        public async Task<string?> Update(string projectId, string userId, string wordId, Word word)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "updating a word in Frontier");

            // We only want to update words that are in the frontier
            var oldWord = await _wordRepo.DeleteFrontier(projectId, wordId);
            if (oldWord is null)
            {
                return null;
            }

            // If an imported word was using the citation form for its Vernacular,
            // only keep UsingCitationForm true if the Vernacular hasn't changed.
            word.UsingCitationForm &= word.Vernacular == oldWord.Vernacular;

            word.ProjectId = projectId;
            word.History.Add(wordId);

            var createdWord = await _wordRepo.Create(PrepEditedData(userId, word));
            await _semDomCountService.UpdateCountsAfterWordUpdate(oldWord, createdWord);

            return createdWord.Id;
        }

        public async Task<bool> ClearFrontier(string projectId)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "clearing the Frontier");

            var success = await _wordRepo.DeleteAllFrontierWords(projectId);
            if (success)
            {
                await _semDomCountRepo.DeleteAllCounts(projectId);
            }
            return success;
        }

        /// <summary> Checks if a word being added is a duplicate of a preexisting word. </summary>
        /// <returns> The id string of the existing word, or null if none. </returns>
        public async Task<string?> FindContainingWord(Word word)
        {
            using var activity = OtelService.StartActivityWithTag(otelTagName, "checking for duplicates of a word");

            var wordsWithVern = await _wordRepo.GetFrontierWithVernacular(word.ProjectId, word.Vernacular);
            var duplicatedWord = wordsWithVern.Find(w => w.Contains(word));
            return duplicatedWord?.Id;
        }
    }
}
