/* tslint:disable */
/* eslint-disable */
/**
 * BackendFramework
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @enum {string}
 */
export enum AutocompleteSetting {
  Off = "Off",
  On = "On",
}

/**
 *
 * @export
 * @interface Credentials
 */
export interface Credentials {
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof Credentials
   */
  password: string;
}
/**
 *
 * @export
 * @interface Edit
 */
export interface Edit {
  /**
   *
   * @type {string}
   * @memberof Edit
   */
  guid: string;
  /**
   *
   * @type {number}
   * @memberof Edit
   */
  goalType: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Edit
   */
  stepData: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Edit
   */
  changes: string;
}
/**
 *
 * @export
 * @interface EmailInvite
 */
export interface EmailInvite {
  /**
   *
   * @type {string}
   * @memberof EmailInvite
   */
  id?: string | null;
  /**
   *
   * @type {string}
   * @memberof EmailInvite
   */
  email?: string | null;
  /**
   *
   * @type {string}
   * @memberof EmailInvite
   */
  token?: string | null;
  /**
   *
   * @type {string}
   * @memberof EmailInvite
   */
  expireTime?: string;
}
/**
 *
 * @export
 * @interface EmailInviteData
 */
export interface EmailInviteData {
  /**
   *
   * @type {string}
   * @memberof EmailInviteData
   */
  emailAddress: string;
  /**
   *
   * @type {string}
   * @memberof EmailInviteData
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof EmailInviteData
   */
  projectId: string;
  /**
   *
   * @type {string}
   * @memberof EmailInviteData
   */
  domain: string;
}
/**
 *
 * @export
 * @interface Gloss
 */
export interface Gloss {
  /**
   *
   * @type {string}
   * @memberof Gloss
   */
  language: string;
  /**
   *
   * @type {string}
   * @memberof Gloss
   */
  def: string;
}
/**
 *
 * @export
 * @interface MergeSourceWord
 */
export interface MergeSourceWord {
  /**
   *
   * @type {string}
   * @memberof MergeSourceWord
   */
  srcWordId: string;
  /**
   *
   * @type {boolean}
   * @memberof MergeSourceWord
   */
  getAudio: boolean;
}
/**
 *
 * @export
 * @interface MergeWords
 */
export interface MergeWords {
  /**
   *
   * @type {Word}
   * @memberof MergeWords
   */
  parent: Word;
  /**
   *
   * @type {Array<MergeSourceWord>}
   * @memberof MergeWords
   */
  children: Array<MergeSourceWord>;
}
/**
 *
 * @export
 * @interface Note
 */
export interface Note {
  /**
   *
   * @type {string}
   * @memberof Note
   */
  language?: string | null;
  /**
   *
   * @type {string}
   * @memberof Note
   */
  text?: string | null;
}
/**
 *
 * @export
 * @interface PasswordResetData
 */
export interface PasswordResetData {
  /**
   *
   * @type {string}
   * @memberof PasswordResetData
   */
  emailOrUsername: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetData
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetData
   */
  newPassword: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetData
   */
  domain: string;
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
  /**
   *
   * @type {string}
   * @memberof Project
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Project
   */
  name: string;
  /**
   *
   * @type {boolean}
   * @memberof Project
   */
  isActive: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Project
   */
  liftImported: boolean;
  /**
   *
   * @type {Array<SemanticDomain>}
   * @memberof Project
   */
  semanticDomains: Array<SemanticDomain>;
  /**
   *
   * @type {WritingSystem}
   * @memberof Project
   */
  vernacularWritingSystem: WritingSystem;
  /**
   *
   * @type {Array<WritingSystem>}
   * @memberof Project
   */
  analysisWritingSystems: Array<WritingSystem>;
  /**
   *
   * @type {Array<string>}
   * @memberof Project
   */
  validCharacters: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Project
   */
  rejectedCharacters: Array<string>;
  /**
   *
   * @type {AutocompleteSetting}
   * @memberof Project
   */
  autocompleteSetting: AutocompleteSetting;
  /**
   *
   * @type {Array<object>}
   * @memberof Project
   */
  customFields: Array<object>;
  /**
   *
   * @type {Array<string>}
   * @memberof Project
   */
  wordFields: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Project
   */
  partsOfSpeech: Array<string>;
  /**
   *
   * @type {Array<EmailInvite>}
   * @memberof Project
   */
  inviteTokens: Array<EmailInvite>;
}
/**
 *
 * @export
 * @interface SemanticDomain
 */
export interface SemanticDomain {
  /**
   *
   * @type {string}
   * @memberof SemanticDomain
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SemanticDomain
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof SemanticDomain
   */
  description: string;
}
/**
 *
 * @export
 * @interface Sense
 */
export interface Sense {
  /**
   *
   * @type {string}
   * @memberof Sense
   */
  guid: string;
  /**
   *
   * @type {Array<Gloss>}
   * @memberof Sense
   */
  glosses: Array<Gloss>;
  /**
   *
   * @type {Array<SemanticDomain>}
   * @memberof Sense
   */
  semanticDomains: Array<SemanticDomain>;
  /**
   *
   * @type {State}
   * @memberof Sense
   */
  accessibility: State;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum State {
  Active = "Active",
  Deleted = "Deleted",
  Sense = "Sense",
  Duplicate = "Duplicate",
  Separate = "Separate",
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  avatar: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  hasAvatar: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  phone: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  otherConnectionField: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof User
   */
  workedProjects: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof User
   */
  projectRoles: { [key: string]: string };
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  agreement: boolean;
  /**
   *
   * @type {string}
   * @memberof User
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  uiLang: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  token: string;
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  isAdmin: boolean;
}
/**
 *
 * @export
 * @interface UserEditStepWrapper
 */
export interface UserEditStepWrapper {
  /**
   *
   * @type {number}
   * @memberof UserEditStepWrapper
   */
  goalIndex: number;
  /**
   *
   * @type {string}
   * @memberof UserEditStepWrapper
   */
  stepString: string;
  /**
   *
   * @type {number}
   * @memberof UserEditStepWrapper
   */
  stepIndex: number;
}
/**
 *
 * @export
 * @interface UserRole
 */
export interface UserRole {
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  id: string;
  /**
   *
   * @type {Array<number>}
   * @memberof UserRole
   */
  permissions: Array<number>;
  /**
   *
   * @type {string}
   * @memberof UserRole
   */
  projectId: string;
}
/**
 *
 * @export
 * @interface Word
 */
export interface Word {
  /**
   *
   * @type {string}
   * @memberof Word
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  guid: string;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  vernacular: string;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  plural: string;
  /**
   *
   * @type {Array<Sense>}
   * @memberof Word
   */
  senses: Array<Sense>;
  /**
   *
   * @type {Array<string>}
   * @memberof Word
   */
  audio: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  created: string;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  modified: string;
  /**
   *
   * @type {State}
   * @memberof Word
   */
  accessibility: State;
  /**
   *
   * @type {Array<string>}
   * @memberof Word
   */
  history: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  partOfSpeech: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Word
   */
  editedBy: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  otherField: string;
  /**
   *
   * @type {string}
   * @memberof Word
   */
  projectId: string;
  /**
   *
   * @type {Note}
   * @memberof Word
   */
  note: Note;
}
/**
 *
 * @export
 * @interface WritingSystem
 */
export interface WritingSystem {
  /**
   *
   * @type {string}
   * @memberof WritingSystem
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof WritingSystem
   */
  bcp47: string;
  /**
   *
   * @type {string}
   * @memberof WritingSystem
   */
  font: string;
}

/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete: async (
      projectId: string,
      wordId: string,
      fileName: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete",
        "wordId",
        wordId
      );
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete",
        "fileName",
        fileName
      );
      const localVarPath = `/v1/projects/{projectId}/words/{wordId}/audio/delete/{fileName}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)))
        .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet: async (
      projectId: string,
      wordId: string,
      fileName: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet",
        "wordId",
        wordId
      );
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet",
        "fileName",
        fileName
      );
      const localVarPath = `/v1/projects/{projectId}/words/{wordId}/audio/download/{fileName}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)))
        .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdAudioUploadPost: async (
      projectId: string,
      wordId: string,
      file: any,
      name: string,
      filePath: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioUploadPost",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioUploadPost",
        "wordId",
        wordId
      );
      // verify required parameter 'file' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioUploadPost",
        "file",
        file
      );
      // verify required parameter 'name' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioUploadPost",
        "name",
        name
      );
      // verify required parameter 'filePath' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdAudioUploadPost",
        "filePath",
        filePath
      );
      const localVarPath = `/v1/projects/{projectId}/words/{wordId}/audio/upload`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (file !== undefined) {
        localVarFormParams.append("File", file as any);
      }

      if (name !== undefined) {
        localVarFormParams.append("Name", name as any);
      }

      if (filePath !== undefined) {
        localVarFormParams.append("FilePath", filePath as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete(
      projectId: string,
      wordId: string,
      fileName: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete(
        projectId,
        wordId,
        fileName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet(
      projectId: string,
      wordId: string,
      fileName: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet(
        projectId,
        wordId,
        fileName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsWordIdAudioUploadPost(
      projectId: string,
      wordId: string,
      file: any,
      name: string,
      filePath: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsWordIdAudioUploadPost(
        projectId,
        wordId,
        file,
        name,
        filePath,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AudioApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete(
      projectId: string,
      wordId: string,
      fileName: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete(
          projectId,
          wordId,
          fileName,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet(
      projectId: string,
      wordId: string,
      fileName: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet(
          projectId,
          wordId,
          fileName,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdAudioUploadPost(
      projectId: string,
      wordId: string,
      file: any,
      name: string,
      filePath: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsWordIdAudioUploadPost(
          projectId,
          wordId,
          file,
          name,
          filePath,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete operation in AudioApi.
 * @export
 * @interface AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDeleteRequest
 */
export interface AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete
   */
  readonly wordId: string;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete
   */
  readonly fileName: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet operation in AudioApi.
 * @export
 * @interface AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGetRequest
 */
export interface AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGetRequest {
  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet
   */
  readonly wordId: string;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet
   */
  readonly fileName: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsWordIdAudioUploadPost operation in AudioApi.
 * @export
 * @interface AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPostRequest
 */
export interface AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPostRequest {
  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPost
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPost
   */
  readonly wordId: string;

  /**
   *
   * @type {any}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPost
   */
  readonly file: any;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPost
   */
  readonly name: string;

  /**
   *
   * @type {string}
   * @memberof AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPost
   */
  readonly filePath: string;
}

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
  /**
   *
   * @param {AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete(
    requestParameters: AudioApiV1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDeleteRequest,
    options?: any
  ) {
    return AudioApiFp(this.configuration)
      .v1ProjectsProjectIdWordsWordIdAudioDeleteFileNameDelete(
        requestParameters.projectId,
        requestParameters.wordId,
        requestParameters.fileName,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet(
    requestParameters: AudioApiV1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGetRequest,
    options?: any
  ) {
    return AudioApiFp(this.configuration)
      .v1ProjectsProjectIdWordsWordIdAudioDownloadFileNameGet(
        requestParameters.projectId,
        requestParameters.wordId,
        requestParameters.fileName,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public v1ProjectsProjectIdWordsWordIdAudioUploadPost(
    requestParameters: AudioApiV1ProjectsProjectIdWordsWordIdAudioUploadPostRequest,
    options?: any
  ) {
    return AudioApiFp(this.configuration)
      .v1ProjectsProjectIdWordsWordIdAudioUploadPost(
        requestParameters.projectId,
        requestParameters.wordId,
        requestParameters.file,
        requestParameters.name,
        requestParameters.filePath,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AvatarApi - axios parameter creator
 * @export
 */
export const AvatarApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdAvatarDownloadGet: async (
      userId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("v1UsersUserIdAvatarDownloadGet", "userId", userId);
      const localVarPath = `/v1/users/{userId}/avatar/download`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdAvatarUploadPost: async (
      userId: string,
      file: any,
      name: string,
      filePath: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("v1UsersUserIdAvatarUploadPost", "userId", userId);
      // verify required parameter 'file' is not null or undefined
      assertParamExists("v1UsersUserIdAvatarUploadPost", "file", file);
      // verify required parameter 'name' is not null or undefined
      assertParamExists("v1UsersUserIdAvatarUploadPost", "name", name);
      // verify required parameter 'filePath' is not null or undefined
      assertParamExists("v1UsersUserIdAvatarUploadPost", "filePath", filePath);
      const localVarPath = `/v1/users/{userId}/avatar/upload`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (file !== undefined) {
        localVarFormParams.append("File", file as any);
      }

      if (name !== undefined) {
        localVarFormParams.append("Name", name as any);
      }

      if (filePath !== undefined) {
        localVarFormParams.append("FilePath", filePath as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AvatarApi - functional programming interface
 * @export
 */
export const AvatarApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AvatarApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersUserIdAvatarDownloadGet(
      userId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdAvatarDownloadGet(
        userId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} userId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersUserIdAvatarUploadPost(
      userId: string,
      file: any,
      name: string,
      filePath: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdAvatarUploadPost(
        userId,
        file,
        name,
        filePath,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AvatarApi - factory interface
 * @export
 */
export const AvatarApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AvatarApiFp(configuration);
  return {
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdAvatarDownloadGet(
      userId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersUserIdAvatarDownloadGet(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdAvatarUploadPost(
      userId: string,
      file: any,
      name: string,
      filePath: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersUserIdAvatarUploadPost(userId, file, name, filePath, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1UsersUserIdAvatarDownloadGet operation in AvatarApi.
 * @export
 * @interface AvatarApiV1UsersUserIdAvatarDownloadGetRequest
 */
export interface AvatarApiV1UsersUserIdAvatarDownloadGetRequest {
  /**
   *
   * @type {string}
   * @memberof AvatarApiV1UsersUserIdAvatarDownloadGet
   */
  readonly userId: string;
}

/**
 * Request parameters for v1UsersUserIdAvatarUploadPost operation in AvatarApi.
 * @export
 * @interface AvatarApiV1UsersUserIdAvatarUploadPostRequest
 */
export interface AvatarApiV1UsersUserIdAvatarUploadPostRequest {
  /**
   *
   * @type {string}
   * @memberof AvatarApiV1UsersUserIdAvatarUploadPost
   */
  readonly userId: string;

  /**
   *
   * @type {any}
   * @memberof AvatarApiV1UsersUserIdAvatarUploadPost
   */
  readonly file: any;

  /**
   *
   * @type {string}
   * @memberof AvatarApiV1UsersUserIdAvatarUploadPost
   */
  readonly name: string;

  /**
   *
   * @type {string}
   * @memberof AvatarApiV1UsersUserIdAvatarUploadPost
   */
  readonly filePath: string;
}

/**
 * AvatarApi - object-oriented interface
 * @export
 * @class AvatarApi
 * @extends {BaseAPI}
 */
export class AvatarApi extends BaseAPI {
  /**
   *
   * @param {AvatarApiV1UsersUserIdAvatarDownloadGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public v1UsersUserIdAvatarDownloadGet(
    requestParameters: AvatarApiV1UsersUserIdAvatarDownloadGetRequest,
    options?: any
  ) {
    return AvatarApiFp(this.configuration)
      .v1UsersUserIdAvatarDownloadGet(requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {AvatarApiV1UsersUserIdAvatarUploadPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AvatarApi
   */
  public v1UsersUserIdAvatarUploadPost(
    requestParameters: AvatarApiV1UsersUserIdAvatarUploadPostRequest,
    options?: any
  ) {
    return AvatarApiFp(this.configuration)
      .v1UsersUserIdAvatarUploadPost(
        requestParameters.userId,
        requestParameters.file,
        requestParameters.name,
        requestParameters.filePath,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FrontierApi - axios parameter creator
 * @export
 */
export const FrontierApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsFrontierGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsFrontierGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/words/frontier`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsFrontierPost: async (
      projectId: string,
      word: Word,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsFrontierPost",
        "projectId",
        projectId
      );
      // verify required parameter 'word' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsFrontierPost", "word", word);
      const localVarPath = `/v1/projects/{projectId}/words/frontier`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        word,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsFrontierWordIdDelete: async (
      projectId: string,
      wordId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsFrontierWordIdDelete",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsFrontierWordIdDelete",
        "wordId",
        wordId
      );
      const localVarPath = `/v1/projects/{projectId}/words/frontier/{wordId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FrontierApi - functional programming interface
 * @export
 */
export const FrontierApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FrontierApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsFrontierGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsFrontierGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsFrontierPost(
      projectId: string,
      word: Word,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsFrontierPost(
        projectId,
        word,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsFrontierWordIdDelete(
      projectId: string,
      wordId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsFrontierWordIdDelete(
        projectId,
        wordId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FrontierApi - factory interface
 * @export
 */
export const FrontierApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FrontierApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsFrontierGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsFrontierGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsFrontierPost(
      projectId: string,
      word: Word,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsFrontierPost(projectId, word, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsFrontierWordIdDelete(
      projectId: string,
      wordId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsFrontierWordIdDelete(
          projectId,
          wordId,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdWordsFrontierGet operation in FrontierApi.
 * @export
 * @interface FrontierApiV1ProjectsProjectIdWordsFrontierGetRequest
 */
export interface FrontierApiV1ProjectsProjectIdWordsFrontierGetRequest {
  /**
   *
   * @type {string}
   * @memberof FrontierApiV1ProjectsProjectIdWordsFrontierGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsFrontierPost operation in FrontierApi.
 * @export
 * @interface FrontierApiV1ProjectsProjectIdWordsFrontierPostRequest
 */
export interface FrontierApiV1ProjectsProjectIdWordsFrontierPostRequest {
  /**
   *
   * @type {string}
   * @memberof FrontierApiV1ProjectsProjectIdWordsFrontierPost
   */
  readonly projectId: string;

  /**
   *
   * @type {Word}
   * @memberof FrontierApiV1ProjectsProjectIdWordsFrontierPost
   */
  readonly word: Word;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsFrontierWordIdDelete operation in FrontierApi.
 * @export
 * @interface FrontierApiV1ProjectsProjectIdWordsFrontierWordIdDeleteRequest
 */
export interface FrontierApiV1ProjectsProjectIdWordsFrontierWordIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof FrontierApiV1ProjectsProjectIdWordsFrontierWordIdDelete
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof FrontierApiV1ProjectsProjectIdWordsFrontierWordIdDelete
   */
  readonly wordId: string;
}

/**
 * FrontierApi - object-oriented interface
 * @export
 * @class FrontierApi
 * @extends {BaseAPI}
 */
export class FrontierApi extends BaseAPI {
  /**
   *
   * @param {FrontierApiV1ProjectsProjectIdWordsFrontierGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FrontierApi
   */
  public v1ProjectsProjectIdWordsFrontierGet(
    requestParameters: FrontierApiV1ProjectsProjectIdWordsFrontierGetRequest,
    options?: any
  ) {
    return FrontierApiFp(this.configuration)
      .v1ProjectsProjectIdWordsFrontierGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FrontierApiV1ProjectsProjectIdWordsFrontierPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FrontierApi
   */
  public v1ProjectsProjectIdWordsFrontierPost(
    requestParameters: FrontierApiV1ProjectsProjectIdWordsFrontierPostRequest,
    options?: any
  ) {
    return FrontierApiFp(this.configuration)
      .v1ProjectsProjectIdWordsFrontierPost(
        requestParameters.projectId,
        requestParameters.word,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FrontierApiV1ProjectsProjectIdWordsFrontierWordIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FrontierApi
   */
  public v1ProjectsProjectIdWordsFrontierWordIdDelete(
    requestParameters: FrontierApiV1ProjectsProjectIdWordsFrontierWordIdDeleteRequest,
    options?: any
  ) {
    return FrontierApiFp(this.configuration)
      .v1ProjectsProjectIdWordsFrontierWordIdDelete(
        requestParameters.projectId,
        requestParameters.wordId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InviteApi - axios parameter creator
 * @export
 */
export const InviteApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1InviteProjectIdValidateTokenPut: async (
      projectId: string,
      token: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1InviteProjectIdValidateTokenPut",
        "projectId",
        projectId
      );
      // verify required parameter 'token' is not null or undefined
      assertParamExists("v1InviteProjectIdValidateTokenPut", "token", token);
      const localVarPath = `/v1/invite/{projectId}/validate/{token}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"token"}}`, encodeURIComponent(String(token)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {EmailInviteData} emailInviteData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1InvitePut: async (
      emailInviteData: EmailInviteData,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'emailInviteData' is not null or undefined
      assertParamExists("v1InvitePut", "emailInviteData", emailInviteData);
      const localVarPath = `/v1/invite`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emailInviteData,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InviteApi - functional programming interface
 * @export
 */
export const InviteApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InviteApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1InviteProjectIdValidateTokenPut(
      projectId: string,
      token: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1InviteProjectIdValidateTokenPut(
        projectId,
        token,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {EmailInviteData} emailInviteData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1InvitePut(
      emailInviteData: EmailInviteData,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1InvitePut(
        emailInviteData,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * InviteApi - factory interface
 * @export
 */
export const InviteApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = InviteApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1InviteProjectIdValidateTokenPut(
      projectId: string,
      token: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1InviteProjectIdValidateTokenPut(projectId, token, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {EmailInviteData} emailInviteData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1InvitePut(
      emailInviteData: EmailInviteData,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1InvitePut(emailInviteData, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1InviteProjectIdValidateTokenPut operation in InviteApi.
 * @export
 * @interface InviteApiV1InviteProjectIdValidateTokenPutRequest
 */
export interface InviteApiV1InviteProjectIdValidateTokenPutRequest {
  /**
   *
   * @type {string}
   * @memberof InviteApiV1InviteProjectIdValidateTokenPut
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof InviteApiV1InviteProjectIdValidateTokenPut
   */
  readonly token: string;
}

/**
 * Request parameters for v1InvitePut operation in InviteApi.
 * @export
 * @interface InviteApiV1InvitePutRequest
 */
export interface InviteApiV1InvitePutRequest {
  /**
   *
   * @type {EmailInviteData}
   * @memberof InviteApiV1InvitePut
   */
  readonly emailInviteData: EmailInviteData;
}

/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
export class InviteApi extends BaseAPI {
  /**
   *
   * @param {InviteApiV1InviteProjectIdValidateTokenPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InviteApi
   */
  public v1InviteProjectIdValidateTokenPut(
    requestParameters: InviteApiV1InviteProjectIdValidateTokenPutRequest,
    options?: any
  ) {
    return InviteApiFp(this.configuration)
      .v1InviteProjectIdValidateTokenPut(
        requestParameters.projectId,
        requestParameters.token,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InviteApiV1InvitePutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InviteApi
   */
  public v1InvitePut(
    requestParameters: InviteApiV1InvitePutRequest,
    options?: any
  ) {
    return InviteApiFp(this.configuration)
      .v1InvitePut(requestParameters.emailInviteData, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LiftApi - axios parameter creator
 * @export
 */
export const LiftApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftCheckGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdLiftCheckGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/lift/check`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftDeleteexportGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdLiftDeleteexportGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/lift/deleteexport`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftDownloadGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdLiftDownloadGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/lift/download`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftExportGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdLiftExportGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/lift/export`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftUploadPost: async (
      projectId: string,
      file: any,
      name: string,
      filePath: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdLiftUploadPost",
        "projectId",
        projectId
      );
      // verify required parameter 'file' is not null or undefined
      assertParamExists("v1ProjectsProjectIdLiftUploadPost", "file", file);
      // verify required parameter 'name' is not null or undefined
      assertParamExists("v1ProjectsProjectIdLiftUploadPost", "name", name);
      // verify required parameter 'filePath' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdLiftUploadPost",
        "filePath",
        filePath
      );
      const localVarPath = `/v1/projects/{projectId}/lift/upload`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      if (file !== undefined) {
        localVarFormParams.append("File", file as any);
      }

      if (name !== undefined) {
        localVarFormParams.append("Name", name as any);
      }

      if (filePath !== undefined) {
        localVarFormParams.append("FilePath", filePath as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LiftApi - functional programming interface
 * @export
 */
export const LiftApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LiftApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdLiftCheckGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdLiftCheckGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdLiftDeleteexportGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdLiftDeleteexportGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdLiftDownloadGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdLiftDownloadGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdLiftExportGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdLiftExportGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdLiftUploadPost(
      projectId: string,
      file: any,
      name: string,
      filePath: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdLiftUploadPost(
        projectId,
        file,
        name,
        filePath,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LiftApi - factory interface
 * @export
 */
export const LiftApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LiftApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftCheckGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdLiftCheckGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftDeleteexportGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdLiftDeleteexportGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftDownloadGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdLiftDownloadGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftExportGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdLiftExportGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {any} file
     * @param {string} name
     * @param {string} filePath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdLiftUploadPost(
      projectId: string,
      file: any,
      name: string,
      filePath: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdLiftUploadPost(
          projectId,
          file,
          name,
          filePath,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdLiftCheckGet operation in LiftApi.
 * @export
 * @interface LiftApiV1ProjectsProjectIdLiftCheckGetRequest
 */
export interface LiftApiV1ProjectsProjectIdLiftCheckGetRequest {
  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftCheckGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdLiftDeleteexportGet operation in LiftApi.
 * @export
 * @interface LiftApiV1ProjectsProjectIdLiftDeleteexportGetRequest
 */
export interface LiftApiV1ProjectsProjectIdLiftDeleteexportGetRequest {
  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftDeleteexportGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdLiftDownloadGet operation in LiftApi.
 * @export
 * @interface LiftApiV1ProjectsProjectIdLiftDownloadGetRequest
 */
export interface LiftApiV1ProjectsProjectIdLiftDownloadGetRequest {
  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftDownloadGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdLiftExportGet operation in LiftApi.
 * @export
 * @interface LiftApiV1ProjectsProjectIdLiftExportGetRequest
 */
export interface LiftApiV1ProjectsProjectIdLiftExportGetRequest {
  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftExportGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdLiftUploadPost operation in LiftApi.
 * @export
 * @interface LiftApiV1ProjectsProjectIdLiftUploadPostRequest
 */
export interface LiftApiV1ProjectsProjectIdLiftUploadPostRequest {
  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftUploadPost
   */
  readonly projectId: string;

  /**
   *
   * @type {any}
   * @memberof LiftApiV1ProjectsProjectIdLiftUploadPost
   */
  readonly file: any;

  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftUploadPost
   */
  readonly name: string;

  /**
   *
   * @type {string}
   * @memberof LiftApiV1ProjectsProjectIdLiftUploadPost
   */
  readonly filePath: string;
}

/**
 * LiftApi - object-oriented interface
 * @export
 * @class LiftApi
 * @extends {BaseAPI}
 */
export class LiftApi extends BaseAPI {
  /**
   *
   * @param {LiftApiV1ProjectsProjectIdLiftCheckGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftApi
   */
  public v1ProjectsProjectIdLiftCheckGet(
    requestParameters: LiftApiV1ProjectsProjectIdLiftCheckGetRequest,
    options?: any
  ) {
    return LiftApiFp(this.configuration)
      .v1ProjectsProjectIdLiftCheckGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LiftApiV1ProjectsProjectIdLiftDeleteexportGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftApi
   */
  public v1ProjectsProjectIdLiftDeleteexportGet(
    requestParameters: LiftApiV1ProjectsProjectIdLiftDeleteexportGetRequest,
    options?: any
  ) {
    return LiftApiFp(this.configuration)
      .v1ProjectsProjectIdLiftDeleteexportGet(
        requestParameters.projectId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LiftApiV1ProjectsProjectIdLiftDownloadGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftApi
   */
  public v1ProjectsProjectIdLiftDownloadGet(
    requestParameters: LiftApiV1ProjectsProjectIdLiftDownloadGetRequest,
    options?: any
  ) {
    return LiftApiFp(this.configuration)
      .v1ProjectsProjectIdLiftDownloadGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LiftApiV1ProjectsProjectIdLiftExportGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftApi
   */
  public v1ProjectsProjectIdLiftExportGet(
    requestParameters: LiftApiV1ProjectsProjectIdLiftExportGetRequest,
    options?: any
  ) {
    return LiftApiFp(this.configuration)
      .v1ProjectsProjectIdLiftExportGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LiftApiV1ProjectsProjectIdLiftUploadPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LiftApi
   */
  public v1ProjectsProjectIdLiftUploadPost(
    requestParameters: LiftApiV1ProjectsProjectIdLiftUploadPostRequest,
    options?: any
  ) {
    return LiftApiFp(this.configuration)
      .v1ProjectsProjectIdLiftUploadPost(
        requestParameters.projectId,
        requestParameters.file,
        requestParameters.name,
        requestParameters.filePath,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MergeApi - axios parameter creator
 * @export
 */
export const MergeApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdMergeBlacklistAddPut: async (
      projectId: string,
      requestBody: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergeBlacklistAddPut",
        "projectId",
        projectId
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergeBlacklistAddPut",
        "requestBody",
        requestBody
      );
      const localVarPath = `/v1/projects/{projectId}/merge/blacklist/add`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {number} maxInList
     * @param {number} maxLists
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet: async (
      projectId: string,
      maxInList: number,
      maxLists: number,
      userId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet",
        "projectId",
        projectId
      );
      // verify required parameter 'maxInList' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet",
        "maxInList",
        maxInList
      );
      // verify required parameter 'maxLists' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet",
        "maxLists",
        maxLists
      );
      // verify required parameter 'userId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet",
        "userId",
        userId
      );
      const localVarPath = `/v1/projects/{projectId}/merge/dups/{maxInList}/{maxLists}/{userid}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"maxInList"}}`, encodeURIComponent(String(maxInList)))
        .replace(`{${"maxLists"}}`, encodeURIComponent(String(maxLists)))
        .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {Array<MergeWords>} mergeWords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdMergePut: async (
      projectId: string,
      mergeWords: Array<MergeWords>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdMergePut", "projectId", projectId);
      // verify required parameter 'mergeWords' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdMergePut",
        "mergeWords",
        mergeWords
      );
      const localVarPath = `/v1/projects/{projectId}/merge`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        mergeWords,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MergeApi - functional programming interface
 * @export
 */
export const MergeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MergeApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdMergeBlacklistAddPut(
      projectId: string,
      requestBody: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdMergeBlacklistAddPut(
        projectId,
        requestBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {number} maxInList
     * @param {number} maxLists
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet(
      projectId: string,
      maxInList: number,
      maxLists: number,
      userId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet(
        projectId,
        maxInList,
        maxLists,
        userId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {Array<MergeWords>} mergeWords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdMergePut(
      projectId: string,
      mergeWords: Array<MergeWords>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdMergePut(
        projectId,
        mergeWords,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MergeApi - factory interface
 * @export
 */
export const MergeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MergeApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdMergeBlacklistAddPut(
      projectId: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdMergeBlacklistAddPut(
          projectId,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {number} maxInList
     * @param {number} maxLists
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet(
      projectId: string,
      maxInList: number,
      maxLists: number,
      userId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet(
          projectId,
          maxInList,
          maxLists,
          userId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {Array<MergeWords>} mergeWords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdMergePut(
      projectId: string,
      mergeWords: Array<MergeWords>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdMergePut(projectId, mergeWords, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdMergeBlacklistAddPut operation in MergeApi.
 * @export
 * @interface MergeApiV1ProjectsProjectIdMergeBlacklistAddPutRequest
 */
export interface MergeApiV1ProjectsProjectIdMergeBlacklistAddPutRequest {
  /**
   *
   * @type {string}
   * @memberof MergeApiV1ProjectsProjectIdMergeBlacklistAddPut
   */
  readonly projectId: string;

  /**
   *
   * @type {Array<string>}
   * @memberof MergeApiV1ProjectsProjectIdMergeBlacklistAddPut
   */
  readonly requestBody: Array<string>;
}

/**
 * Request parameters for v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet operation in MergeApi.
 * @export
 * @interface MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGetRequest
 */
export interface MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGetRequest {
  /**
   *
   * @type {string}
   * @memberof MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet
   */
  readonly projectId: string;

  /**
   *
   * @type {number}
   * @memberof MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet
   */
  readonly maxInList: number;

  /**
   *
   * @type {number}
   * @memberof MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet
   */
  readonly maxLists: number;

  /**
   *
   * @type {string}
   * @memberof MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet
   */
  readonly userId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdMergePut operation in MergeApi.
 * @export
 * @interface MergeApiV1ProjectsProjectIdMergePutRequest
 */
export interface MergeApiV1ProjectsProjectIdMergePutRequest {
  /**
   *
   * @type {string}
   * @memberof MergeApiV1ProjectsProjectIdMergePut
   */
  readonly projectId: string;

  /**
   *
   * @type {Array<MergeWords>}
   * @memberof MergeApiV1ProjectsProjectIdMergePut
   */
  readonly mergeWords: Array<MergeWords>;
}

/**
 * MergeApi - object-oriented interface
 * @export
 * @class MergeApi
 * @extends {BaseAPI}
 */
export class MergeApi extends BaseAPI {
  /**
   *
   * @param {MergeApiV1ProjectsProjectIdMergeBlacklistAddPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MergeApi
   */
  public v1ProjectsProjectIdMergeBlacklistAddPut(
    requestParameters: MergeApiV1ProjectsProjectIdMergeBlacklistAddPutRequest,
    options?: any
  ) {
    return MergeApiFp(this.configuration)
      .v1ProjectsProjectIdMergeBlacklistAddPut(
        requestParameters.projectId,
        requestParameters.requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MergeApi
   */
  public v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet(
    requestParameters: MergeApiV1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGetRequest,
    options?: any
  ) {
    return MergeApiFp(this.configuration)
      .v1ProjectsProjectIdMergeDupsMaxInListMaxListsUseridGet(
        requestParameters.projectId,
        requestParameters.maxInList,
        requestParameters.maxLists,
        requestParameters.userId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {MergeApiV1ProjectsProjectIdMergePutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MergeApi
   */
  public v1ProjectsProjectIdMergePut(
    requestParameters: MergeApiV1ProjectsProjectIdMergePutRequest,
    options?: any
  ) {
    return MergeApiFp(this.configuration)
      .v1ProjectsProjectIdMergePut(
        requestParameters.projectId,
        requestParameters.mergeWords,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsDelete: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/projects`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsDuplicateProjectNameGet: async (
      projectName: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectName' is not null or undefined
      assertParamExists(
        "v1ProjectsDuplicateProjectNameGet",
        "projectName",
        projectName
      );
      const localVarPath = `/v1/projects/duplicate/{projectName}`.replace(
        `{${"projectName"}}`,
        encodeURIComponent(String(projectName))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/projects`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsPost: async (
      project: Project,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'project' is not null or undefined
      assertParamExists("v1ProjectsPost", "project", project);
      const localVarPath = `/v1/projects`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        project,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdCharactersPut: async (
      projectId: string,
      project: Project,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdCharactersPut",
        "projectId",
        projectId
      );
      // verify required parameter 'project' is not null or undefined
      assertParamExists("v1ProjectsProjectIdCharactersPut", "project", project);
      const localVarPath = `/v1/projects/{projectId}/characters`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        project,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdDelete: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdDelete", "projectId", projectId);
      const localVarPath = `/v1/projects/{projectId}`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdGet", "projectId", projectId);
      const localVarPath = `/v1/projects/{projectId}`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdPut: async (
      projectId: string,
      project: Project,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdPut", "projectId", projectId);
      // verify required parameter 'project' is not null or undefined
      assertParamExists("v1ProjectsProjectIdPut", "project", project);
      const localVarPath = `/v1/projects/{projectId}`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        project,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdSemanticdomainsGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdSemanticdomainsGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/semanticdomains`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsersGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdUsersGet", "projectId", projectId);
      const localVarPath = `/v1/projects/{projectId}/users`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsDelete(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsDelete(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsDuplicateProjectNameGet(
      projectName: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsDuplicateProjectNameGet(
        projectName,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsPost(
      project: Project,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsPost(
        project,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdCharactersPut(
      projectId: string,
      project: Project,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdCharactersPut(
        projectId,
        project,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdDelete(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdDelete(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdPut(
      projectId: string,
      project: Project,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdPut(
        projectId,
        project,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdSemanticdomainsGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdSemanticdomainsGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsersGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsersGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProjectApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsDelete(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsDelete(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsDuplicateProjectNameGet(
      projectName: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsDuplicateProjectNameGet(projectName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsPost(project: Project, options?: any): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsPost(project, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdCharactersPut(
      projectId: string,
      project: Project,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdCharactersPut(projectId, project, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdDelete(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdDelete(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {Project} project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdPut(
      projectId: string,
      project: Project,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdPut(projectId, project, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdSemanticdomainsGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdSemanticdomainsGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsersGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsersGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsDuplicateProjectNameGet operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsDuplicateProjectNameGetRequest
 */
export interface ProjectApiV1ProjectsDuplicateProjectNameGetRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsDuplicateProjectNameGet
   */
  readonly projectName: string;
}

/**
 * Request parameters for v1ProjectsPost operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsPostRequest
 */
export interface ProjectApiV1ProjectsPostRequest {
  /**
   *
   * @type {Project}
   * @memberof ProjectApiV1ProjectsPost
   */
  readonly project: Project;
}

/**
 * Request parameters for v1ProjectsProjectIdCharactersPut operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsProjectIdCharactersPutRequest
 */
export interface ProjectApiV1ProjectsProjectIdCharactersPutRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsProjectIdCharactersPut
   */
  readonly projectId: string;

  /**
   *
   * @type {Project}
   * @memberof ProjectApiV1ProjectsProjectIdCharactersPut
   */
  readonly project: Project;
}

/**
 * Request parameters for v1ProjectsProjectIdDelete operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsProjectIdDeleteRequest
 */
export interface ProjectApiV1ProjectsProjectIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsProjectIdDelete
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdGet operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsProjectIdGetRequest
 */
export interface ProjectApiV1ProjectsProjectIdGetRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsProjectIdGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdPut operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsProjectIdPutRequest
 */
export interface ProjectApiV1ProjectsProjectIdPutRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsProjectIdPut
   */
  readonly projectId: string;

  /**
   *
   * @type {Project}
   * @memberof ProjectApiV1ProjectsProjectIdPut
   */
  readonly project: Project;
}

/**
 * Request parameters for v1ProjectsProjectIdSemanticdomainsGet operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsProjectIdSemanticdomainsGetRequest
 */
export interface ProjectApiV1ProjectsProjectIdSemanticdomainsGetRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsProjectIdSemanticdomainsGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUsersGet operation in ProjectApi.
 * @export
 * @interface ProjectApiV1ProjectsProjectIdUsersGetRequest
 */
export interface ProjectApiV1ProjectsProjectIdUsersGetRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectApiV1ProjectsProjectIdUsersGet
   */
  readonly projectId: string;
}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsDelete(options?: any) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsDelete(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsDuplicateProjectNameGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsDuplicateProjectNameGet(
    requestParameters: ProjectApiV1ProjectsDuplicateProjectNameGetRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsDuplicateProjectNameGet(requestParameters.projectName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsGet(options?: any) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsPost(
    requestParameters: ProjectApiV1ProjectsPostRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsPost(requestParameters.project, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsProjectIdCharactersPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsProjectIdCharactersPut(
    requestParameters: ProjectApiV1ProjectsProjectIdCharactersPutRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsProjectIdCharactersPut(
        requestParameters.projectId,
        requestParameters.project,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsProjectIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsProjectIdDelete(
    requestParameters: ProjectApiV1ProjectsProjectIdDeleteRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsProjectIdDelete(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsProjectIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsProjectIdGet(
    requestParameters: ProjectApiV1ProjectsProjectIdGetRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsProjectIdGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsProjectIdPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsProjectIdPut(
    requestParameters: ProjectApiV1ProjectsProjectIdPutRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsProjectIdPut(
        requestParameters.projectId,
        requestParameters.project,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsProjectIdSemanticdomainsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsProjectIdSemanticdomainsGet(
    requestParameters: ProjectApiV1ProjectsProjectIdSemanticdomainsGetRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsProjectIdSemanticdomainsGet(
        requestParameters.projectId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ProjectApiV1ProjectsProjectIdUsersGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public v1ProjectsProjectIdUsersGet(
    requestParameters: ProjectApiV1ProjectsProjectIdUsersGetRequest,
    options?: any
  ) {
    return ProjectApiFp(this.configuration)
      .v1ProjectsProjectIdUsersGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {Credentials} credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersAuthenticatePost: async (
      credentials: Credentials,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'credentials' is not null or undefined
      assertParamExists("v1UsersAuthenticatePost", "credentials", credentials);
      const localVarPath = `/v1/users/authenticate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        credentials,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersCheckemailEmailPost: async (
      email: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists("v1UsersCheckemailEmailPost", "email", email);
      const localVarPath = `/v1/users/checkemail/{email}`.replace(
        `{${"email"}}`,
        encodeURIComponent(String(email))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersCheckusernameUsernamePost: async (
      username: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists(
        "v1UsersCheckusernameUsernamePost",
        "username",
        username
      );
      const localVarPath = `/v1/users/checkusername/{username}`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersDelete: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PasswordResetData} passwordResetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersForgotPost: async (
      passwordResetData: PasswordResetData,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'passwordResetData' is not null or undefined
      assertParamExists(
        "v1UsersForgotPost",
        "passwordResetData",
        passwordResetData
      );
      const localVarPath = `/v1/users/forgot`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        passwordResetData,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PasswordResetData} passwordResetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersForgotResetPost: async (
      passwordResetData: PasswordResetData,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'passwordResetData' is not null or undefined
      assertParamExists(
        "v1UsersForgotResetPost",
        "passwordResetData",
        passwordResetData
      );
      const localVarPath = `/v1/users/forgot/reset`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        passwordResetData,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersPost: async (
      user: User,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'user' is not null or undefined
      assertParamExists("v1UsersPost", "user", user);
      const localVarPath = `/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdDelete: async (
      userId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("v1UsersUserIdDelete", "userId", userId);
      const localVarPath = `/v1/users/{userId}`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdGet: async (
      userId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("v1UsersUserIdGet", "userId", userId);
      const localVarPath = `/v1/users/{userId}`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdPut: async (
      userId: string,
      user: User,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("v1UsersUserIdPut", "userId", userId);
      // verify required parameter 'user' is not null or undefined
      assertParamExists("v1UsersUserIdPut", "user", user);
      const localVarPath = `/v1/users/{userId}`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        user,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {Credentials} credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersAuthenticatePost(
      credentials: Credentials,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersAuthenticatePost(
        credentials,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersCheckemailEmailPost(
      email: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersCheckemailEmailPost(
        email,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersCheckusernameUsernamePost(
      username: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersCheckusernameUsernamePost(
        username,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersDelete(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersDelete(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {PasswordResetData} passwordResetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersForgotPost(
      passwordResetData: PasswordResetData,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersForgotPost(
        passwordResetData,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {PasswordResetData} passwordResetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersForgotResetPost(
      passwordResetData: PasswordResetData,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersForgotResetPost(
        passwordResetData,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersPost(
      user: User,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersPost(
        user,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersUserIdDelete(
      userId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdDelete(
        userId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersUserIdGet(
      userId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdGet(
        userId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1UsersUserIdPut(
      userId: string,
      user: User,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1UsersUserIdPut(
        userId,
        user,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @param {Credentials} credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersAuthenticatePost(
      credentials: Credentials,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersAuthenticatePost(credentials, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersCheckemailEmailPost(
      email: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersCheckemailEmailPost(email, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersCheckusernameUsernamePost(
      username: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersCheckusernameUsernamePost(username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersDelete(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1UsersDelete(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PasswordResetData} passwordResetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersForgotPost(
      passwordResetData: PasswordResetData,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersForgotPost(passwordResetData, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PasswordResetData} passwordResetData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersForgotResetPost(
      passwordResetData: PasswordResetData,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersForgotResetPost(passwordResetData, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .v1UsersGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersPost(user: User, options?: any): AxiosPromise<void> {
      return localVarFp
        .v1UsersPost(user, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdDelete(userId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .v1UsersUserIdDelete(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdGet(userId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .v1UsersUserIdGet(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userId
     * @param {User} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1UsersUserIdPut(
      userId: string,
      user: User,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1UsersUserIdPut(userId, user, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1UsersAuthenticatePost operation in UserApi.
 * @export
 * @interface UserApiV1UsersAuthenticatePostRequest
 */
export interface UserApiV1UsersAuthenticatePostRequest {
  /**
   *
   * @type {Credentials}
   * @memberof UserApiV1UsersAuthenticatePost
   */
  readonly credentials: Credentials;
}

/**
 * Request parameters for v1UsersCheckemailEmailPost operation in UserApi.
 * @export
 * @interface UserApiV1UsersCheckemailEmailPostRequest
 */
export interface UserApiV1UsersCheckemailEmailPostRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiV1UsersCheckemailEmailPost
   */
  readonly email: string;
}

/**
 * Request parameters for v1UsersCheckusernameUsernamePost operation in UserApi.
 * @export
 * @interface UserApiV1UsersCheckusernameUsernamePostRequest
 */
export interface UserApiV1UsersCheckusernameUsernamePostRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiV1UsersCheckusernameUsernamePost
   */
  readonly username: string;
}

/**
 * Request parameters for v1UsersForgotPost operation in UserApi.
 * @export
 * @interface UserApiV1UsersForgotPostRequest
 */
export interface UserApiV1UsersForgotPostRequest {
  /**
   *
   * @type {PasswordResetData}
   * @memberof UserApiV1UsersForgotPost
   */
  readonly passwordResetData: PasswordResetData;
}

/**
 * Request parameters for v1UsersForgotResetPost operation in UserApi.
 * @export
 * @interface UserApiV1UsersForgotResetPostRequest
 */
export interface UserApiV1UsersForgotResetPostRequest {
  /**
   *
   * @type {PasswordResetData}
   * @memberof UserApiV1UsersForgotResetPost
   */
  readonly passwordResetData: PasswordResetData;
}

/**
 * Request parameters for v1UsersPost operation in UserApi.
 * @export
 * @interface UserApiV1UsersPostRequest
 */
export interface UserApiV1UsersPostRequest {
  /**
   *
   * @type {User}
   * @memberof UserApiV1UsersPost
   */
  readonly user: User;
}

/**
 * Request parameters for v1UsersUserIdDelete operation in UserApi.
 * @export
 * @interface UserApiV1UsersUserIdDeleteRequest
 */
export interface UserApiV1UsersUserIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiV1UsersUserIdDelete
   */
  readonly userId: string;
}

/**
 * Request parameters for v1UsersUserIdGet operation in UserApi.
 * @export
 * @interface UserApiV1UsersUserIdGetRequest
 */
export interface UserApiV1UsersUserIdGetRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiV1UsersUserIdGet
   */
  readonly userId: string;
}

/**
 * Request parameters for v1UsersUserIdPut operation in UserApi.
 * @export
 * @interface UserApiV1UsersUserIdPutRequest
 */
export interface UserApiV1UsersUserIdPutRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiV1UsersUserIdPut
   */
  readonly userId: string;

  /**
   *
   * @type {User}
   * @memberof UserApiV1UsersUserIdPut
   */
  readonly user: User;
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @param {UserApiV1UsersAuthenticatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersAuthenticatePost(
    requestParameters: UserApiV1UsersAuthenticatePostRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersAuthenticatePost(requestParameters.credentials, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersCheckemailEmailPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersCheckemailEmailPost(
    requestParameters: UserApiV1UsersCheckemailEmailPostRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersCheckemailEmailPost(requestParameters.email, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersCheckusernameUsernamePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersCheckusernameUsernamePost(
    requestParameters: UserApiV1UsersCheckusernameUsernamePostRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersCheckusernameUsernamePost(requestParameters.username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersDelete(options?: any) {
    return UserApiFp(this.configuration)
      .v1UsersDelete(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersForgotPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersForgotPost(
    requestParameters: UserApiV1UsersForgotPostRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersForgotPost(requestParameters.passwordResetData, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersForgotResetPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersForgotResetPost(
    requestParameters: UserApiV1UsersForgotResetPostRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersForgotResetPost(requestParameters.passwordResetData, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersGet(options?: any) {
    return UserApiFp(this.configuration)
      .v1UsersGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersPost(
    requestParameters: UserApiV1UsersPostRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersPost(requestParameters.user, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersUserIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersUserIdDelete(
    requestParameters: UserApiV1UsersUserIdDeleteRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersUserIdDelete(requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersUserIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersUserIdGet(
    requestParameters: UserApiV1UsersUserIdGetRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersUserIdGet(requestParameters.userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserApiV1UsersUserIdPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public v1UsersUserIdPut(
    requestParameters: UserApiV1UsersUserIdPutRequest,
    options?: any
  ) {
    return UserApiFp(this.configuration)
      .v1UsersUserIdPut(
        requestParameters.userId,
        requestParameters.user,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserEditApi - axios parameter creator
 * @export
 */
export const UserEditApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsDelete: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsDelete",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/useredits`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/useredits`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsPost: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsPost",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/useredits`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdDelete: async (
      projectId: string,
      userEditId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdDelete",
        "projectId",
        projectId
      );
      // verify required parameter 'userEditId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdDelete",
        "userEditId",
        userEditId
      );
      const localVarPath = `/v1/projects/{projectId}/useredits/{userEditId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userEditId"}}`, encodeURIComponent(String(userEditId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdGet: async (
      projectId: string,
      userEditId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdGet",
        "projectId",
        projectId
      );
      // verify required parameter 'userEditId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdGet",
        "userEditId",
        userEditId
      );
      const localVarPath = `/v1/projects/{projectId}/useredits/{userEditId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userEditId"}}`, encodeURIComponent(String(userEditId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {Edit} edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdPost: async (
      projectId: string,
      userEditId: string,
      edit: Edit,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdPost",
        "projectId",
        projectId
      );
      // verify required parameter 'userEditId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdPost",
        "userEditId",
        userEditId
      );
      // verify required parameter 'edit' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdPost",
        "edit",
        edit
      );
      const localVarPath = `/v1/projects/{projectId}/useredits/{userEditId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userEditId"}}`, encodeURIComponent(String(userEditId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        edit,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {UserEditStepWrapper} userEditStepWrapper
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdPut: async (
      projectId: string,
      userEditId: string,
      userEditStepWrapper: UserEditStepWrapper,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdPut",
        "projectId",
        projectId
      );
      // verify required parameter 'userEditId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdPut",
        "userEditId",
        userEditId
      );
      // verify required parameter 'userEditStepWrapper' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUsereditsUserEditIdPut",
        "userEditStepWrapper",
        userEditStepWrapper
      );
      const localVarPath = `/v1/projects/{projectId}/useredits/{userEditId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userEditId"}}`, encodeURIComponent(String(userEditId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userEditStepWrapper,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserEditApi - functional programming interface
 * @export
 */
export const UserEditApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserEditApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsDelete(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsDelete(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsPost(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsPost(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsUserEditIdDelete(
      projectId: string,
      userEditId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsUserEditIdDelete(
        projectId,
        userEditId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsUserEditIdGet(
      projectId: string,
      userEditId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsUserEditIdGet(
        projectId,
        userEditId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {Edit} edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsUserEditIdPost(
      projectId: string,
      userEditId: string,
      edit: Edit,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsUserEditIdPost(
        projectId,
        userEditId,
        edit,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {UserEditStepWrapper} userEditStepWrapper
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUsereditsUserEditIdPut(
      projectId: string,
      userEditId: string,
      userEditStepWrapper: UserEditStepWrapper,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUsereditsUserEditIdPut(
        projectId,
        userEditId,
        userEditStepWrapper,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserEditApi - factory interface
 * @export
 */
export const UserEditApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserEditApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsDelete(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsDelete(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsPost(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsPost(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdDelete(
      projectId: string,
      userEditId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsUserEditIdDelete(
          projectId,
          userEditId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdGet(
      projectId: string,
      userEditId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsUserEditIdGet(
          projectId,
          userEditId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {Edit} edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdPost(
      projectId: string,
      userEditId: string,
      edit: Edit,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsUserEditIdPost(
          projectId,
          userEditId,
          edit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userEditId
     * @param {UserEditStepWrapper} userEditStepWrapper
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUsereditsUserEditIdPut(
      projectId: string,
      userEditId: string,
      userEditStepWrapper: UserEditStepWrapper,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUsereditsUserEditIdPut(
          projectId,
          userEditId,
          userEditStepWrapper,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdUsereditsDelete operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsDeleteRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsDelete
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUsereditsGet operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsGetRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsGetRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUsereditsPost operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsPostRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsPostRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsPost
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUsereditsUserEditIdDelete operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdDeleteRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdDelete
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdDelete
   */
  readonly userEditId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUsereditsUserEditIdGet operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdGetRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdGetRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdGet
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdGet
   */
  readonly userEditId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUsereditsUserEditIdPost operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPostRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPostRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPost
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPost
   */
  readonly userEditId: string;

  /**
   *
   * @type {Edit}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPost
   */
  readonly edit: Edit;
}

/**
 * Request parameters for v1ProjectsProjectIdUsereditsUserEditIdPut operation in UserEditApi.
 * @export
 * @interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPutRequest
 */
export interface UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPutRequest {
  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPut
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPut
   */
  readonly userEditId: string;

  /**
   *
   * @type {UserEditStepWrapper}
   * @memberof UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPut
   */
  readonly userEditStepWrapper: UserEditStepWrapper;
}

/**
 * UserEditApi - object-oriented interface
 * @export
 * @class UserEditApi
 * @extends {BaseAPI}
 */
export class UserEditApi extends BaseAPI {
  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsDelete(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsDeleteRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsDelete(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsGet(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsGetRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsPost(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsPostRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsPost(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsUserEditIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsUserEditIdDelete(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsUserEditIdDeleteRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsUserEditIdDelete(
        requestParameters.projectId,
        requestParameters.userEditId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsUserEditIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsUserEditIdGet(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsUserEditIdGetRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsUserEditIdGet(
        requestParameters.projectId,
        requestParameters.userEditId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsUserEditIdPost(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPostRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsUserEditIdPost(
        requestParameters.projectId,
        requestParameters.userEditId,
        requestParameters.edit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserEditApi
   */
  public v1ProjectsProjectIdUsereditsUserEditIdPut(
    requestParameters: UserEditApiV1ProjectsProjectIdUsereditsUserEditIdPutRequest,
    options?: any
  ) {
    return UserEditApiFp(this.configuration)
      .v1ProjectsProjectIdUsereditsUserEditIdPut(
        requestParameters.projectId,
        requestParameters.userEditId,
        requestParameters.userEditStepWrapper,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserRoleApi - axios parameter creator
 * @export
 */
export const UserRoleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesDelete: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesDelete",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/userroles`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesGet",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/userroles`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {UserRole} userRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesPost: async (
      projectId: string,
      userRole: UserRole,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesPost",
        "projectId",
        projectId
      );
      // verify required parameter 'userRole' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesPost",
        "userRole",
        userRole
      );
      const localVarPath = `/v1/projects/{projectId}/userroles`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRole,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userId
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesUserIdPut: async (
      projectId: string,
      userId: string,
      requestBody: Array<number>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserIdPut",
        "projectId",
        projectId
      );
      // verify required parameter 'userId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserIdPut",
        "userId",
        userId
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserIdPut",
        "requestBody",
        requestBody
      );
      const localVarPath = `/v1/projects/{projectId}/userroles/{userId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesUserRoleIdDelete: async (
      projectId: string,
      userRoleId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserRoleIdDelete",
        "projectId",
        projectId
      );
      // verify required parameter 'userRoleId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserRoleIdDelete",
        "userRoleId",
        userRoleId
      );
      const localVarPath = `/v1/projects/{projectId}/userroles/{userRoleId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userRoleId"}}`, encodeURIComponent(String(userRoleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesUserRoleIdGet: async (
      projectId: string,
      userRoleId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserRoleIdGet",
        "projectId",
        projectId
      );
      // verify required parameter 'userRoleId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdUserrolesUserRoleIdGet",
        "userRoleId",
        userRoleId
      );
      const localVarPath = `/v1/projects/{projectId}/userroles/{userRoleId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"userRoleId"}}`, encodeURIComponent(String(userRoleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserRoleApi - functional programming interface
 * @export
 */
export const UserRoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserRoleApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUserrolesDelete(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUserrolesDelete(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUserrolesGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUserrolesGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {UserRole} userRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUserrolesPost(
      projectId: string,
      userRole: UserRole,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUserrolesPost(
        projectId,
        userRole,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userId
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUserrolesUserIdPut(
      projectId: string,
      userId: string,
      requestBody: Array<number>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUserrolesUserIdPut(
        projectId,
        userId,
        requestBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUserrolesUserRoleIdDelete(
      projectId: string,
      userRoleId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUserrolesUserRoleIdDelete(
        projectId,
        userRoleId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdUserrolesUserRoleIdGet(
      projectId: string,
      userRoleId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdUserrolesUserRoleIdGet(
        projectId,
        userRoleId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserRoleApi - factory interface
 * @export
 */
export const UserRoleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserRoleApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesDelete(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUserrolesDelete(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUserrolesGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {UserRole} userRole
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesPost(
      projectId: string,
      userRole: UserRole,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUserrolesPost(projectId, userRole, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userId
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesUserIdPut(
      projectId: string,
      userId: string,
      requestBody: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUserrolesUserIdPut(
          projectId,
          userId,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesUserRoleIdDelete(
      projectId: string,
      userRoleId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUserrolesUserRoleIdDelete(
          projectId,
          userRoleId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} userRoleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdUserrolesUserRoleIdGet(
      projectId: string,
      userRoleId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdUserrolesUserRoleIdGet(
          projectId,
          userRoleId,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdUserrolesDelete operation in UserRoleApi.
 * @export
 * @interface UserRoleApiV1ProjectsProjectIdUserrolesDeleteRequest
 */
export interface UserRoleApiV1ProjectsProjectIdUserrolesDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesDelete
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUserrolesGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiV1ProjectsProjectIdUserrolesGetRequest
 */
export interface UserRoleApiV1ProjectsProjectIdUserrolesGetRequest {
  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUserrolesPost operation in UserRoleApi.
 * @export
 * @interface UserRoleApiV1ProjectsProjectIdUserrolesPostRequest
 */
export interface UserRoleApiV1ProjectsProjectIdUserrolesPostRequest {
  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesPost
   */
  readonly projectId: string;

  /**
   *
   * @type {UserRole}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesPost
   */
  readonly userRole: UserRole;
}

/**
 * Request parameters for v1ProjectsProjectIdUserrolesUserIdPut operation in UserRoleApi.
 * @export
 * @interface UserRoleApiV1ProjectsProjectIdUserrolesUserIdPutRequest
 */
export interface UserRoleApiV1ProjectsProjectIdUserrolesUserIdPutRequest {
  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserIdPut
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserIdPut
   */
  readonly userId: string;

  /**
   *
   * @type {Array<number>}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserIdPut
   */
  readonly requestBody: Array<number>;
}

/**
 * Request parameters for v1ProjectsProjectIdUserrolesUserRoleIdDelete operation in UserRoleApi.
 * @export
 * @interface UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdDeleteRequest
 */
export interface UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdDelete
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdDelete
   */
  readonly userRoleId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdUserrolesUserRoleIdGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdGetRequest
 */
export interface UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdGetRequest {
  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdGet
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdGet
   */
  readonly userRoleId: string;
}

/**
 * UserRoleApi - object-oriented interface
 * @export
 * @class UserRoleApi
 * @extends {BaseAPI}
 */
export class UserRoleApi extends BaseAPI {
  /**
   *
   * @param {UserRoleApiV1ProjectsProjectIdUserrolesDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRoleApi
   */
  public v1ProjectsProjectIdUserrolesDelete(
    requestParameters: UserRoleApiV1ProjectsProjectIdUserrolesDeleteRequest,
    options?: any
  ) {
    return UserRoleApiFp(this.configuration)
      .v1ProjectsProjectIdUserrolesDelete(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserRoleApiV1ProjectsProjectIdUserrolesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRoleApi
   */
  public v1ProjectsProjectIdUserrolesGet(
    requestParameters: UserRoleApiV1ProjectsProjectIdUserrolesGetRequest,
    options?: any
  ) {
    return UserRoleApiFp(this.configuration)
      .v1ProjectsProjectIdUserrolesGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserRoleApiV1ProjectsProjectIdUserrolesPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRoleApi
   */
  public v1ProjectsProjectIdUserrolesPost(
    requestParameters: UserRoleApiV1ProjectsProjectIdUserrolesPostRequest,
    options?: any
  ) {
    return UserRoleApiFp(this.configuration)
      .v1ProjectsProjectIdUserrolesPost(
        requestParameters.projectId,
        requestParameters.userRole,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserRoleApiV1ProjectsProjectIdUserrolesUserIdPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRoleApi
   */
  public v1ProjectsProjectIdUserrolesUserIdPut(
    requestParameters: UserRoleApiV1ProjectsProjectIdUserrolesUserIdPutRequest,
    options?: any
  ) {
    return UserRoleApiFp(this.configuration)
      .v1ProjectsProjectIdUserrolesUserIdPut(
        requestParameters.projectId,
        requestParameters.userId,
        requestParameters.requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRoleApi
   */
  public v1ProjectsProjectIdUserrolesUserRoleIdDelete(
    requestParameters: UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdDeleteRequest,
    options?: any
  ) {
    return UserRoleApiFp(this.configuration)
      .v1ProjectsProjectIdUserrolesUserRoleIdDelete(
        requestParameters.projectId,
        requestParameters.userRoleId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserRoleApi
   */
  public v1ProjectsProjectIdUserrolesUserRoleIdGet(
    requestParameters: UserRoleApiV1ProjectsProjectIdUserrolesUserRoleIdGetRequest,
    options?: any
  ) {
    return UserRoleApiFp(this.configuration)
      .v1ProjectsProjectIdUserrolesUserRoleIdGet(
        requestParameters.projectId,
        requestParameters.userRoleId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * WordApi - axios parameter creator
 * @export
 */
export const WordApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsDelete: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsDelete",
        "projectId",
        projectId
      );
      const localVarPath = `/v1/projects/{projectId}/words`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsGet: async (
      projectId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsGet", "projectId", projectId);
      const localVarPath = `/v1/projects/{projectId}/words`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsPost: async (
      projectId: string,
      word: Word,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsPost", "projectId", projectId);
      // verify required parameter 'word' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsPost", "word", word);
      const localVarPath = `/v1/projects/{projectId}/words`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        word,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdDelete: async (
      projectId: string,
      wordId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdDelete",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdDelete",
        "wordId",
        wordId
      );
      const localVarPath = `/v1/projects/{projectId}/words/{wordId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdGet: async (
      projectId: string,
      wordId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdGet",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsWordIdGet", "wordId", wordId);
      const localVarPath = `/v1/projects/{projectId}/words/{wordId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdPut: async (
      projectId: string,
      wordId: string,
      word: Word,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "v1ProjectsProjectIdWordsWordIdPut",
        "projectId",
        projectId
      );
      // verify required parameter 'wordId' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsWordIdPut", "wordId", wordId);
      // verify required parameter 'word' is not null or undefined
      assertParamExists("v1ProjectsProjectIdWordsWordIdPut", "word", word);
      const localVarPath = `/v1/projects/{projectId}/words/{wordId}`
        .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
        .replace(`{${"wordId"}}`, encodeURIComponent(String(wordId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json-patch+json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        word,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * WordApi - functional programming interface
 * @export
 */
export const WordApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WordApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsDelete(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsDelete(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsGet(
      projectId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsGet(
        projectId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsPost(
      projectId: string,
      word: Word,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsPost(
        projectId,
        word,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsWordIdDelete(
      projectId: string,
      wordId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsWordIdDelete(
        projectId,
        wordId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsWordIdGet(
      projectId: string,
      wordId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsWordIdGet(
        projectId,
        wordId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1ProjectsProjectIdWordsWordIdPut(
      projectId: string,
      wordId: string,
      word: Word,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1ProjectsProjectIdWordsWordIdPut(
        projectId,
        wordId,
        word,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * WordApi - factory interface
 * @export
 */
export const WordApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WordApiFp(configuration);
  return {
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsDelete(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsDelete(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsGet(
      projectId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsGet(projectId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsPost(
      projectId: string,
      word: Word,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsPost(projectId, word, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdDelete(
      projectId: string,
      wordId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsWordIdDelete(projectId, wordId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdGet(
      projectId: string,
      wordId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsWordIdGet(projectId, wordId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} projectId
     * @param {string} wordId
     * @param {Word} word
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1ProjectsProjectIdWordsWordIdPut(
      projectId: string,
      wordId: string,
      word: Word,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .v1ProjectsProjectIdWordsWordIdPut(projectId, wordId, word, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for v1ProjectsProjectIdWordsDelete operation in WordApi.
 * @export
 * @interface WordApiV1ProjectsProjectIdWordsDeleteRequest
 */
export interface WordApiV1ProjectsProjectIdWordsDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsDelete
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsGet operation in WordApi.
 * @export
 * @interface WordApiV1ProjectsProjectIdWordsGetRequest
 */
export interface WordApiV1ProjectsProjectIdWordsGetRequest {
  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsGet
   */
  readonly projectId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsPost operation in WordApi.
 * @export
 * @interface WordApiV1ProjectsProjectIdWordsPostRequest
 */
export interface WordApiV1ProjectsProjectIdWordsPostRequest {
  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsPost
   */
  readonly projectId: string;

  /**
   *
   * @type {Word}
   * @memberof WordApiV1ProjectsProjectIdWordsPost
   */
  readonly word: Word;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsWordIdDelete operation in WordApi.
 * @export
 * @interface WordApiV1ProjectsProjectIdWordsWordIdDeleteRequest
 */
export interface WordApiV1ProjectsProjectIdWordsWordIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdDelete
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdDelete
   */
  readonly wordId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsWordIdGet operation in WordApi.
 * @export
 * @interface WordApiV1ProjectsProjectIdWordsWordIdGetRequest
 */
export interface WordApiV1ProjectsProjectIdWordsWordIdGetRequest {
  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdGet
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdGet
   */
  readonly wordId: string;
}

/**
 * Request parameters for v1ProjectsProjectIdWordsWordIdPut operation in WordApi.
 * @export
 * @interface WordApiV1ProjectsProjectIdWordsWordIdPutRequest
 */
export interface WordApiV1ProjectsProjectIdWordsWordIdPutRequest {
  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdPut
   */
  readonly projectId: string;

  /**
   *
   * @type {string}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdPut
   */
  readonly wordId: string;

  /**
   *
   * @type {Word}
   * @memberof WordApiV1ProjectsProjectIdWordsWordIdPut
   */
  readonly word: Word;
}

/**
 * WordApi - object-oriented interface
 * @export
 * @class WordApi
 * @extends {BaseAPI}
 */
export class WordApi extends BaseAPI {
  /**
   *
   * @param {WordApiV1ProjectsProjectIdWordsDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordApi
   */
  public v1ProjectsProjectIdWordsDelete(
    requestParameters: WordApiV1ProjectsProjectIdWordsDeleteRequest,
    options?: any
  ) {
    return WordApiFp(this.configuration)
      .v1ProjectsProjectIdWordsDelete(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {WordApiV1ProjectsProjectIdWordsGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordApi
   */
  public v1ProjectsProjectIdWordsGet(
    requestParameters: WordApiV1ProjectsProjectIdWordsGetRequest,
    options?: any
  ) {
    return WordApiFp(this.configuration)
      .v1ProjectsProjectIdWordsGet(requestParameters.projectId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {WordApiV1ProjectsProjectIdWordsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordApi
   */
  public v1ProjectsProjectIdWordsPost(
    requestParameters: WordApiV1ProjectsProjectIdWordsPostRequest,
    options?: any
  ) {
    return WordApiFp(this.configuration)
      .v1ProjectsProjectIdWordsPost(
        requestParameters.projectId,
        requestParameters.word,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {WordApiV1ProjectsProjectIdWordsWordIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordApi
   */
  public v1ProjectsProjectIdWordsWordIdDelete(
    requestParameters: WordApiV1ProjectsProjectIdWordsWordIdDeleteRequest,
    options?: any
  ) {
    return WordApiFp(this.configuration)
      .v1ProjectsProjectIdWordsWordIdDelete(
        requestParameters.projectId,
        requestParameters.wordId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {WordApiV1ProjectsProjectIdWordsWordIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordApi
   */
  public v1ProjectsProjectIdWordsWordIdGet(
    requestParameters: WordApiV1ProjectsProjectIdWordsWordIdGetRequest,
    options?: any
  ) {
    return WordApiFp(this.configuration)
      .v1ProjectsProjectIdWordsWordIdGet(
        requestParameters.projectId,
        requestParameters.wordId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {WordApiV1ProjectsProjectIdWordsWordIdPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordApi
   */
  public v1ProjectsProjectIdWordsWordIdPut(
    requestParameters: WordApiV1ProjectsProjectIdWordsWordIdPutRequest,
    options?: any
  ) {
    return WordApiFp(this.configuration)
      .v1ProjectsProjectIdWordsWordIdPut(
        requestParameters.projectId,
        requestParameters.wordId,
        requestParameters.word,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
